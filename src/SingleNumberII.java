
public class SingleNumberII {
	 /*
		 * 给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。
		 * 算法思想：	按位计算。int型数字占32位，如果这个数字出现3次，则与这个数字对应的每一位上的1也出现三次。
		 * 			使用int型数组记录A数组中所有数值转换为二进制，其中每一位上1出现的次数，记录总次数，能被3整除则表示出现3次。
		 * 			最后得到的就是要求的数字。
	     * @param A: An integer array
	     * @return: An integer
	     */
	    public int singleNumberII(int[] A) {
	        // write your code here
	    	int result = 0;
	    	if(A.length == 0 || A == null)  {
	    		return result;
	    	}
	    	int[] bits = new int[32];  //用来记录A数组中的所有数据转换为二进制后，其中每一位上1出现的总次数
	    	for(int i = 0; i < 32; i++) {
	    		
	    		/** A[j] >> i & 1 的思想：
				 *  举例说明： A[j]为任意小于32位的数字， 假设此处转换为二进制为 0000 0000 0000 0000 1011 0111 1111 0110;
				 *  假设i=7(从0开始)
				 *  A[j] >> 7 为  0000 0000 0000 0000 0000 0001 0110 1111
				 *  (A[j] >> 7) & 1 = 0000 0000 0000 0000 0000 0000 0000 0001 
				 *  相当于将A[j]转换为二进制后，在第i位的值置于末尾，然后通过遍历A数组，从而求得第i位上1出现的总次数
				 */
	    		for(int j = 0; j < A.length; j++) {
	    			bits[i] += A[j] >> i & 1;   
	    		}
	    		
	    		/**
	    		 * 因为数组个数为3*n + 1，那么第i位的值要么为0,或者为3的倍数(3*m),或者为3的倍数+1(3*k + 1)
	    		 * 将bits[i]为3的倍数的值重置为bits[i] % 3;
	    		 * 其实该算法可用于求解给出k*n + 1 个的数字，除其中一个数字之外其他每个数字均出现K次，找到这个数字。
	    		 * 只需bits[i] = bits[i] % k;即可
	    		 * bits[i]数组保存的即为reslut的二进制，只不过是将二进制割裂放在数组中而已，将其转换为真正意义上的二进制即可。
	    		 */
	    		bits[i] = bits[i] % 3; 
	    		result |= bits[i] << i; //转换为真正意义上的二进制
	    	}
	        return result;
	    }
}
